{"ast":null,"code":"function rootReducer(state = initialState, action) {\n  const currentPlayerId = state.currentTurnPlayer;\n  switch (action.type) {\n    case \"HIT_MONSTER\":\n      const {\n        monsterDamage\n      } = action.payload;\n      return {\n        ...state,\n        monster: {\n          ...state.monster,\n          pv: Math.max(state.monster.pv - monsterDamage, 0)\n        }\n      };\n    case \"HIT_PLAYER\":\n      const {\n        damage\n      } = action.payload;\n      const attackingPlayer = state.players.find(player => player.id === action.payload.playerId);\n      if (attackingPlayer) {\n        const damageAbility = attackingPlayer.abilities.find(a => a.type === 'damage');\n        const manaCost = damageAbility ? damageAbility.manaCost : 0;\n        if (attackingPlayer.mana >= manaCost) {\n          const updatedPlayers = state.players.map(player => player.id === action.payload.playerId ? {\n            ...player,\n            pv: Math.max(Math.min(player.pv - damage, player.pvMax), 0),\n            mana: Math.max(player.mana - manaCost, 0)\n          } : player);\n          return {\n            ...state,\n            players: updatedPlayers\n          };\n        }\n      }\n\n      // Si le joueur n'a pas assez de mana ou si l'ability n'est pas trouvée, retournez simplement l'état actuel\n      return state;\n    case \"HEAL_PLAYER\":\n      const {\n        healPlayer\n      } = action.payload;\n      return {\n        ...state,\n        players: state.players.map(player => {\n          if (player.id === healPlayer.id) {\n            return {\n              ...player,\n              pv: Math.min(player.pv + healPlayer.heal, player.pvMax)\n            };\n          }\n          return player;\n        })\n      };\n    case \"FIRE_BALL\":\n      const currentPlayer = state.players.find(player => player.id === currentPlayerId);\n      if (currentPlayer && !currentPlayer.hasPerformedAction) {\n        const {\n          fireBall\n        } = action.payload;\n        const updatedPlayers = state.players.map(player => player.id === fireBall.id ? {\n          ...player,\n          pv: Math.max(player.pv - fireBall.damage, 0),\n          mana: Math.max(player.mana - fireBall.manaCost, 0),\n          hasPerformedAction: true\n        } : player);\n        return {\n          ...state,\n          players: updatedPlayers,\n          monster: {\n            ...state.monster,\n            pv: Math.max(state.monster.pv - fireBall.damage, 0)\n          }\n        };\n      }\n      return state;\n    case \"MANA_PLAYER\":\n      const {\n        manaPlayer\n      } = action.payload;\n      return {\n        ...state,\n        players: state.players.map(player => {\n          if (player.id === manaPlayer.id) {\n            return {\n              ...player,\n              mana: Math.min(player.mana + manaPlayer.mana, player.manaMax)\n            };\n          }\n          return player;\n        })\n      };\n    case \"NEXT_TURN\":\n      const nextTurnPlayerId = currentPlayerId % state.players.length + 1;\n      const resetPlayers = state.players.map(player => ({\n        ...player,\n        hasPerformedAction: false\n      }));\n      return {\n        ...state,\n        players: resetPlayers,\n        currentTurnPlayer: nextTurnPlayerId\n      };\n    case \"PLAYER_DEAD\":\n      const {\n        playerId\n      } = action.payload;\n      return {\n        ...state,\n        players: state.players.map(player => ({\n          ...player,\n          pv: player.id === playerId ? 0 : player.pv\n        }))\n      };\n    default:\n      return state;\n  }\n}\nexport default rootReducer;","map":{"version":3,"names":["rootReducer","state","initialState","action","currentPlayerId","currentTurnPlayer","type","monsterDamage","payload","monster","pv","Math","max","damage","attackingPlayer","players","find","player","id","playerId","damageAbility","abilities","a","manaCost","mana","updatedPlayers","map","min","pvMax","healPlayer","heal","currentPlayer","hasPerformedAction","fireBall","manaPlayer","manaMax","nextTurnPlayerId","length","resetPlayers"],"sources":["/home/g404/Documents/Random-Rumblee/src/store/rootReducer.js"],"sourcesContent":["function rootReducer(state = initialState, action) {\n  const currentPlayerId = state.currentTurnPlayer;\n\n  switch (action.type) {\n    case \"HIT_MONSTER\":\n      const { monsterDamage } = action.payload;\n      return {\n        ...state,\n        monster: {\n          ...state.monster,\n          pv: Math.max(state.monster.pv - monsterDamage, 0),\n        },\n      };\n\n    case \"HIT_PLAYER\":\n      const { damage } = action.payload;\n      const attackingPlayer = state.players.find(player => player.id === action.payload.playerId);\n\n      if (attackingPlayer) {\n        const damageAbility = attackingPlayer.abilities.find(a => a.type === 'damage');\n        const manaCost = damageAbility ? damageAbility.manaCost : 0;\n\n        if (attackingPlayer.mana >= manaCost) {\n          const updatedPlayers = state.players.map((player) =>\n            player.id === action.payload.playerId\n              ? {\n                ...player,\n                pv: Math.max(Math.min(player.pv - damage, player.pvMax), 0),\n                mana: Math.max(player.mana - manaCost, 0),\n              }\n              : player\n          );\n\n          return {\n            ...state,\n            players: updatedPlayers,\n          };\n        }\n      }\n\n      // Si le joueur n'a pas assez de mana ou si l'ability n'est pas trouvée, retournez simplement l'état actuel\n      return state;\n\n    case \"HEAL_PLAYER\":\n      const { healPlayer } = action.payload;\n      return {\n        ...state,\n        players: state.players.map((player) => {\n          if (player.id === healPlayer.id) {\n            return {\n              ...player,\n              pv: Math.min(player.pv + healPlayer.heal, player.pvMax),\n            };\n          }\n          return player;\n        }),\n      };\n\n    case \"FIRE_BALL\":\n      const currentPlayer = state.players.find(player => player.id === currentPlayerId);\n\n      if (currentPlayer && !currentPlayer.hasPerformedAction) {\n        const { fireBall } = action.payload;\n        const updatedPlayers = state.players.map(player =>\n          player.id === fireBall.id\n            ? {\n              ...player,\n              pv: Math.max(player.pv - fireBall.damage, 0),\n              mana: Math.max(player.mana - fireBall.manaCost, 0),\n              hasPerformedAction: true,\n            }\n            : player\n        );\n\n        return {\n          ...state,\n          players: updatedPlayers,\n          monster: {\n            ...state.monster,\n            pv: Math.max(state.monster.pv - fireBall.damage, 0),\n          },\n        };\n      }\n      return state;\n\n    case \"MANA_PLAYER\":\n      const { manaPlayer } = action.payload;\n      return {\n        ...state,\n        players: state.players.map((player) => {\n          if (player.id === manaPlayer.id) {\n            return {\n              ...player,\n              mana: Math.min(player.mana + manaPlayer.mana, player.manaMax),\n            };\n          }\n          return player;\n        }),\n      };\n\n    case \"NEXT_TURN\":\n      const nextTurnPlayerId = (currentPlayerId % state.players.length) + 1;\n\n      const resetPlayers = state.players.map((player) => ({\n        ...player,\n        hasPerformedAction: false,\n      }));\n\n      return {\n        ...state,\n        players: resetPlayers,\n        currentTurnPlayer: nextTurnPlayerId,\n      };\n\n    case \"PLAYER_DEAD\":\n      const { playerId } = action.payload;\n      return {\n        ...state,\n        players: state.players.map((player) => ({\n          ...player,\n          pv: player.id === playerId ? 0 : player.pv,\n        })),\n      };\n\n    default:\n      return state;\n  }\n}\n\nexport default rootReducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}